<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API Reference :: Go Kure</title><link>https://www.gokure.dev/api-reference/index.html</link><description>API Reference Kure‚Äôs public API is organized into focused packages. Each package README below is auto-synced from the source code.
For full Go API documentation, see pkg.go.dev/github.com/go-kure/kure .
Core Domain Package Description Reference Stack Cluster, Node, Bundle, Application domain model pkg.go.dev Flux Engine FluxCD workflow implementation pkg.go.dev Generators Application generator system (GVK) pkg.go.dev Layout Engine Manifest directory organization pkg.go.dev Package System Package Description Reference Launcher Kurel package loading, building, validation pkg.go.dev Resource Operations Package Description Reference Patch JSONPath-based declarative patching pkg.go.dev IO YAML/JSON serialization and resource printing pkg.go.dev Kubernetes Builders Core K8s resource constructors (GVK, HPA, PDB) pkg.go.dev FluxCD Builders Low-level Flux resource constructors pkg.go.dev Utilities Package Description Reference Errors Structured error types pkg.go.dev CLI Utilities Factory, IOStreams, Printer pkg.go.dev Logger Structured logging pkg.go.dev Compatibility Compatibility Matrix - Supported Kubernetes and dependency versions ArgoCD ArgoCD support exists at pkg/stack/argocd/ but is not yet production-ready. It is not featured in guides or examples. The Flux workflow is the primary supported GitOps integration.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://www.gokure.dev/api-reference/index.xml" rel="self" type="application/rss+xml"/><item><title>Stack</title><link>https://www.gokure.dev/api-reference/stack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/stack/index.html</guid><description>Stack - Core Domain Model The stack package defines the hierarchical domain model at the heart of Kure. It provides the Cluster, Node, Bundle, and Application abstractions used to describe a complete Kubernetes deployment topology.
Overview Kure models Kubernetes infrastructure as a four-level hierarchy:
Cluster ‚îî‚îÄ‚îÄ Node (tree structure) ‚îî‚îÄ‚îÄ Bundle (deployment unit) ‚îî‚îÄ‚îÄ Application (workload) Each level maps to a concept in GitOps deployment:
Level Purpose GitOps Mapping Cluster Target cluster Root directory Node Organizational grouping (e.g., infrastructure, apps) Subdirectory tree Bundle Deployment unit with dependencies Flux Kustomization / ArgoCD Application Application Individual workload or resource set Kubernetes manifests Key Types Cluster The root of the hierarchy, representing a complete cluster configuration.</description></item><item><title>Flux Engine</title><link>https://www.gokure.dev/api-reference/flux-engine/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/flux-engine/index.html</guid><description>Flux Engine - FluxCD Workflow Implementation The fluxcd package implements the stack.Workflow interface for FluxCD, providing complete Flux resource generation from domain model definitions.
Overview The Flux engine transforms Kure‚Äôs hierarchical domain model (Cluster, Node, Bundle, Application) into FluxCD resources (Kustomizations, source references) organized in a GitOps-ready directory structure.
The engine is composed of three specialized components:
Component Responsibility ResourceGenerator Generates Flux resources from domain objects LayoutIntegrator Integrates resources into directory structures BootstrapGenerator Creates Flux bootstrap manifests Quick Start import "github.com/go-kure/kure/pkg/stack/fluxcd" // Create engine with defaults engine := fluxcd.Engine() // Generate all Flux resources for a cluster objects, err := engine.GenerateFromCluster(cluster) // Or with custom configuration engine = fluxcd.EngineWithConfig( layout.KustomizationExplicit, layout.FluxSeparate, ) Engine Construction // Default engine engine := fluxcd.Engine() // Engine with specific kustomization mode engine := fluxcd.EngineWithMode(layout.KustomizationExplicit) // Engine with full configuration engine := fluxcd.EngineWithConfig(mode, placement) // Engine with custom components engine := fluxcd.NewWorkflowEngine() Resource Generation Generate Flux resources at different hierarchy levels:</description></item><item><title>Generators</title><link>https://www.gokure.dev/api-reference/generators/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/generators/index.html</guid><description>Generators - Application Generator System The generators package provides a type-safe system for creating Kubernetes application workloads from configuration. Generators implement the stack.ApplicationConfig interface, allowing them to be used as applications within the domain model.
Overview Generators use the GroupVersionKind (GVK) type system to identify and instantiate application configurations. Each generator is registered in the stack package‚Äôs global registry and can be referenced by its GVK identifier.
Available Generators Generator GVK Description AppWorkload generators/AppWorkload General-purpose application workload with Deployment, Service, ConfigMap FluxHelm generators/FluxHelm HelmRelease-based application using Flux KurelPackage generators/KurelPackage Kurel package reference for pre-built application packages Usage Creating a Generator from GVK import "github.com/go-kure/kure/pkg/stack" // Create application config by apiVersion and kind config, err := stack.CreateApplicationConfig("generators.gokure.dev/v1alpha1", "AppWorkload") // Use in domain model app := stack.NewApplication("my-app", "default", config) YAML Configuration Format Generators are typically configured via YAML:</description></item><item><title>Layout Engine</title><link>https://www.gokure.dev/api-reference/layout/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/layout/index.html</guid><description>Layout Module The layout module is a sophisticated system for organizing and writing Kubernetes manifests to disk in directory structures that work with GitOps tools like Flux and ArgoCD.
Core Purpose The layout module transforms Kure‚Äôs in-memory stack representation (Clusters ‚Üí Nodes ‚Üí Bundles ‚Üí Applications) into organized directory structures with proper kustomization.yaml files that GitOps tools can consume.
Key Components 1. ManifestLayout Structure Central data structure representing a directory with its resources and children Contains: Name, Namespace, Resources (K8s objects), Children (subdirectories) Supports package-aware layouts for multi-OCI/Git scenarios 2. LayoutRules Configuration NodeGrouping: How nodes are organized (GroupByName creates dirs, GroupFlat flattens) BundleGrouping: How bundles within nodes are organized ApplicationGrouping: How applications within bundles are organized FilePer: How resources are written (FilePerResource vs FilePerKind) FluxPlacement: Where Flux Kustomizations go (FluxSeparate vs FluxIntegrated) 3. Two Main Walker Functions WalkCluster(): Standard hierarchical layout (Node ‚Üí Bundle ‚Üí App structure) WalkClusterByPackage(): Groups by PackageRef for multi-source scenarios 4. Writing System WriteManifest(): Standard hierarchical writing WritePackagesToDisk(): Package-based writing with sanitized directory names Auto-generates kustomization.yaml files with proper resource references Directory Structure Patterns Standard Layout (WalkCluster) clusters/ cluster-name/ node1/ bundle1/ app1/ manifest-files.yaml kustomization.yaml app2/... bundle2/... node2/... Package-Based Layout (WalkClusterByPackage) oci-packages/ cluster/ web/ app-manifests.yaml git-packages/ cluster/ monitoring/ app-manifests.yaml Flat Layout (GroupFlat rules) clusters/ cluster-name/ all-manifests-together.yaml kustomization.yaml GitOps Tool Compatibility Flux Integration Uses spec.path: ./clusters/cluster-name/node format Auto-generates kustomization.yaml files Supports recursive discovery of manifests Handles FluxSeparate vs FluxIntegrated placement modes ArgoCD Integration Uses spec.source.path: clusters/cluster-name/node format Requires explicit kustomization.yaml files (no auto-discovery) Each target directory needs its own Application Advanced Features Package Reference Support Tracks different source types (OCIRepository, GitRepository, Bucket) Enables multi-source deployments with proper isolation Sanitizes package keys into valid directory names Flexible File Organization FilePerResource: Each K8s object gets its own file FilePerKind: Group objects by Kind (all Services together, etc.) AppFileSingle: All app resources in one file Kustomization Generation KustomizationExplicit: Lists all manifest files explicitly KustomizationRecursive: References subdirectories only Smart handling of cross-references and child relationships Real-World Use Cases Simple Cluster: Single source, hierarchical structure Multi-OCI Deployment: Different services from different OCI registries Monorepo: Everything flattened into minimal directory structure Bootstrap Scenarios: Special handling for Flux/ArgoCD system components Example Usage // Create layout rules rules := layout.DefaultLayoutRules() rules.BundleGrouping = layout.GroupFlat rules.ApplicationGrouping = layout.GroupFlat // Walk cluster to create layout ml, err := layout.WalkCluster(cluster, rules) if err != nil { return err } // Write to disk cfg := layout.DefaultLayoutConfig() err = layout.WriteManifest("out/manifests", cfg, ml) Key Files types.go: Core types and configuration options walker.go: Tree traversal algorithms (WalkCluster, WalkClusterByPackage) manifest.go: ManifestLayout structure and package-based writing write.go: Standard manifest writing with kustomization generation config.go: Configuration and file naming conventions The layout module essentially bridges the gap between Kure‚Äôs programmatic resource construction and the file-based expectations of GitOps workflows, with extensive configurability for different organizational preferences and tool requirements.</description></item><item><title>Launcher</title><link>https://www.gokure.dev/api-reference/launcher/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/launcher/index.html</guid><description>Launcher - Kubernetes Resources Launcher This package provides the core functionality for Kurel, the Kubernetes Resources Launcher CLI tool.
Kurel is a package system for creating reusable, customizable Kubernetes applications without the complexity of templating engines. It uses a declarative patch-based approach to customize base Kubernetes manifests, making it perfect for GitOps workflows.
‚ú® Key Features üì¶ Package-based - Encapsulate applications in reusable .kurel packages üéØ No Templating - Use patches instead of complex template syntax üîß Declarative Customization - Simple parameter-driven configuration üöÄ GitOps Native - Generate clean Kubernetes manifests for Flux/ArgoCD üìä Schema Validation - Auto-generated schemas with Kubernetes API integration üèóÔ∏è Multi-Phase Deployment - Support for ordered deployment phases üåê Multi-Namespace - Deploy across multiple namespaces seamlessly üé® User Extensions - Extend packages without modifying originals üöÄ Quick Start Installing a Package # Download a kurel package (example) git clone https://github.com/example/prometheus-operator.kurel # Validate the package kurel validate prometheus-operator.kurel/ # Customize with your parameters cat &gt; my-values.yaml &lt;&lt; EOF monitoring: enabled: true retention: 7d persistence: enabled: true size: 50Gi resources: requests: cpu: 200m memory: 512Mi EOF # Generate manifests kurel build prometheus-operator.kurel/ \ --values my-values.yaml \ --output ./manifests/ Using with GitOps # Generated structure is GitOps-ready ls manifests/ # pre-install/ - CRDs, namespaces, RBAC # main/ - Main application (depends on pre-install) # post-install/ - Monitoring, backups (depends on main) # Each phase includes kustomization.yaml with proper dependencies cat manifests/main/kustomization.yaml # apiVersion: kustomize.config.k8s.io/v1beta1 # kind: Kustomization # dependsOn: # - name: prometheus-pre-install # resources: [...] üìÅ Package Structure A kurel package is a directory with this structure:</description></item><item><title>Patch</title><link>https://www.gokure.dev/api-reference/patch/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/patch/index.html</guid><description>Patch - Declarative Resource Patching The patch package provides a JSONPath-based system for declaratively modifying Kubernetes resources. It supports both TOML and YAML patch file formats with structure-preserving modifications and variable substitution.
Overview Patches allow you to modify Kubernetes manifests without rewriting them. The system uses JSONPath expressions to target specific fields and applies changes while preserving the original YAML structure (comments, ordering, formatting).
Patch File Formats TOML Format (.kpatch) # Target a specific resource by kind and name [deployment.myapp.spec] replicas = 3 [deployment.myapp.spec.template.spec.containers.0] image = "${app.image}:${app.tag}" resources.requests.cpu = "200m" resources.requests.memory = "256Mi" # Append to a list with .- [deployment.myapp.spec.template.spec.containers.-] name = "sidecar" image = "envoy:latest" YAML Format target: kind: Deployment name: myapp patches: - path: spec.replicas value: 3 - path: spec.template.spec.containers[0].image value: "nginx:latest" Quick Start import "github.com/go-kure/kure/pkg/patch" // Load patches from file file, _ := os.Open("patches/customize.kpatch") specs, err := patch.LoadPatchFile(file) // Create patchable set with resources and patches patchSet, err := patch.NewPatchableAppSet(resources, specs) // Resolve targets and apply resolved, err := patchSet.Resolve() for _, r := range resolved { err := r.Apply() } // Write patched output err = patchSet.WriteToFile("output.yaml") Key Features Variable Substitution Patches support variable references that resolve against a parameter context:</description></item><item><title>IO</title><link>https://www.gokure.dev/api-reference/io/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/io/index.html</guid><description>IO - YAML Serialization and Resource Printing The io package provides utilities for parsing, serializing, and printing Kubernetes resources. It supports multiple output formats including YAML, JSON, and kubectl-compatible table views.
Overview This package handles the I/O boundary of Kure: reading Kubernetes manifests from files, serializing resources to YAML/JSON, and printing resources in human-readable formats. It integrates with Kure‚Äôs registered scheme for type-aware parsing.
Parsing Parse YAML Files import "github.com/go-kure/kure/pkg/io" // Parse a multi-document YAML file into typed Kubernetes objects objects, err := io.ParseFile("manifests/deployment.yaml") // Parse YAML bytes directly objects, err := io.ParseYAML(yamlData) Unstructured Fallback By default, only GVKs registered in the kure scheme are accepted. To parse arbitrary Kubernetes YAML (CRDs, custom operators, etc.) use ParseYAMLWithOptions or ParseFileWithOptions with AllowUnstructured:</description></item><item><title>Errors</title><link>https://www.gokure.dev/api-reference/errors/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/errors/index.html</guid><description>Errors - Structured Error Handling The errors package provides structured error types with contextual information for Kubernetes resource operations. All Kure packages use this instead of fmt.Errorf.
Overview Errors in Kure carry context: the type of error, what resource was affected, suggestions for fixing the problem, and the original cause. This makes debugging easier and enables programmatic error handling.
Error Types Type Use Case Key Fields ValidationError Field validation failures Field, Value, ValidValues, Suggestion ResourceError Resource-specific issues Kind, Name, Namespace, Available PatchError Patch operation failures Operation, Path, ResourceName ParseError File/YAML parsing errors Source, Line, Column FileError File system operations Operation, Path ConfigError Configuration problems Source, Field, Value, ValidValues Usage Wrapping Errors import "github.com/go-kure/kure/pkg/errors" // Wrap with context if err != nil { return errors.Wrap(err, "failed to load cluster config") } // Wrap with formatted message return errors.Wrapf(err, "resource %s/%s not found", kind, name) Creating Errors // Simple error return errors.New("invalid configuration") // Formatted error return errors.Errorf("unknown generator: %s", name) Typed Errors // Validation error with suggestion return errors.NewValidationError( "replicas", // field "-1", // value "Deployment", // component []string{"1", "3"}, // valid values ) // Resource not found return errors.ResourceNotFoundError( "Deployment", // resource type "my-app", // name "default", // namespace []string{"web-app", "api-app"}, // available resources ) // Patch error return errors.NewPatchError( "set", // operation "spec.replicas", // path "my-deployment", // resource name "field not found", // reason originalErr, // cause ) // Parse error with location return errors.NewParseError( "config.yaml", // source file "invalid YAML", // reason 42, // line 10, // column originalErr, // cause ) // File error return errors.NewFileError("read", "/path/to/file", "permission denied", originalErr) // Configuration error return errors.NewConfigError( "mise.toml", // source "go", // field "1.21", // value "version too old", // reason []string{"1.23", "1.24"}, // valid values ) Inspecting Errors // Check if error is a Kure error if errors.IsKureError(err) { kErr := errors.GetKureError(err) fmt.Println(kErr.Type()) fmt.Println(kErr.Suggestion()) } // Check specific error type if errors.IsType(err, errors.ErrorTypeValidation) { // Handle validation error } Predefined Errors Common nil-resource errors are predefined for use throughout Kure:</description></item><item><title>CLI Utilities</title><link>https://www.gokure.dev/api-reference/cli/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/cli/index.html</guid><description>CLI - Command-Line Interface Utilities The cli package provides foundational components for Kure‚Äôs CLI tools (kure and kurel). It implements the Factory pattern for dependency injection, I/O stream abstraction, and output formatting.
Overview This package is used internally by the pkg/cmd/ packages to build CLI commands. It provides a clean separation between command logic and I/O handling.
Key Components Factory Dependency injection container for CLI commands. Provides access to global options, I/O streams, and configuration.</description></item><item><title>Kubernetes Builders</title><link>https://www.gokure.dev/api-reference/kubernetes-builders/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/kubernetes-builders/index.html</guid><description>Kubernetes Builders - Core Resource Helpers The kubernetes package provides GVK utilities, scheme registration, and strongly-typed builder functions for core Kubernetes resources.
Overview This package exposes helpers that other Kure packages (and external consumers such as Crane) use to construct and inspect Kubernetes objects without dealing with low-level struct details.
Import import "github.com/go-kure/kure/pkg/kubernetes" GVK Utilities // Resolve the GVK of any registered runtime.Object gvk, err := kubernetes.GetGroupVersionKind(myDeployment) // Check if a GVK is in an allow list ok := kubernetes.IsGVKAllowed(gvk, allowedGVKs) Scheme Registration // Lazily registers all supported API groups (core K8s, FluxCD, cert-manager, etc.) err := kubernetes.RegisterSchemes() HPA Builders // Create a HorizontalPodAutoscaler hpa := kubernetes.CreateHorizontalPodAutoscaler("my-app", "default") // Set the scale target err := kubernetes.SetHPAScaleTargetRef(hpa, "apps/v1", "Deployment", "my-app") // Set replica bounds err = kubernetes.SetHPAMinMaxReplicas(hpa, 2, 10) // Add CPU and memory metrics err = kubernetes.AddHPACPUMetric(hpa, 80) err = kubernetes.AddHPAMemoryMetric(hpa, 70) // Set scaling behavior window := int32(300) err = kubernetes.SetHPABehavior(hpa, &amp;autoscalingv2.HorizontalPodAutoscalerBehavior{ ScaleDown: &amp;autoscalingv2.HPAScalingRules{ StabilizationWindowSeconds: &amp;window, }, }) // Update metadata err = kubernetes.SetHPALabels(hpa, map[string]string{"env": "prod"}) err = kubernetes.SetHPAAnnotations(hpa, map[string]string{"owner": "platform"}) PDB Builders // Create a PodDisruptionBudget pdb := kubernetes.CreatePodDisruptionBudget("my-app", "default") // Set disruption budget (MinAvailable and MaxUnavailable are mutually exclusive) err := kubernetes.SetPDBMinAvailable(pdb, intstr.FromInt32(2)) // or: err = kubernetes.SetPDBMaxUnavailable(pdb, intstr.FromString("25%")) // Set the label selector err = kubernetes.SetPDBSelector(pdb, &amp;metav1.LabelSelector{ MatchLabels: map[string]string{"app": "my-app"}, }) // Update metadata err = kubernetes.SetPDBLabels(pdb, map[string]string{"env": "prod"}) err = kubernetes.SetPDBAnnotations(pdb, map[string]string{"owner": "platform"}) Deployment Builders // Create a Deployment dep := kubernetes.CreateDeployment("my-app", "default") // Add a container container := &amp;corev1.Container{Name: "app", Image: "nginx:1.25"} err := kubernetes.AddDeploymentContainer(dep, container) // Set replicas and strategy err = kubernetes.SetDeploymentReplicas(dep, 3) err = kubernetes.SetDeploymentStrategy(dep, appsv1.DeploymentStrategy{ Type: appsv1.RollingUpdateDeploymentStrategyType, }) // Configure pod template err = kubernetes.SetDeploymentServiceAccountName(dep, "my-sa") err = kubernetes.SetDeploymentNodeSelector(dep, map[string]string{"role": "web"}) err = kubernetes.AddDeploymentToleration(dep, &amp;corev1.Toleration{Key: "dedicated", Value: "web"}) CronJob Builders // Create a CronJob cj := kubernetes.CreateCronJob("my-job", "default", "*/5 * * * *") // Add a container container := &amp;corev1.Container{Name: "worker", Image: "busybox:1.36"} err := kubernetes.AddCronJobContainer(cj, container) // Configure schedule and policies err = kubernetes.SetCronJobConcurrencyPolicy(cj, batchv1.ForbidConcurrent) err = kubernetes.SetCronJobSuccessfulJobsHistoryLimit(cj, 3) err = kubernetes.SetCronJobFailedJobsHistoryLimit(cj, 1) // Configure pod template err = kubernetes.SetCronJobServiceAccountName(cj, "my-sa") err = kubernetes.SetCronJobNodeSelector(cj, map[string]string{"role": "batch"}) err = kubernetes.AddCronJobToleration(cj, &amp;corev1.Toleration{Key: "dedicated", Value: "batch"}) Service Builders // Create a Service svc := kubernetes.CreateService("my-app", "default") // Configure the service err := kubernetes.SetServiceSelector(svc, map[string]string{"app": "my-app"}) err = kubernetes.AddServicePort(svc, corev1.ServicePort{ Name: "http", Port: 80, TargetPort: intstr.FromInt32(8080), }) err = kubernetes.SetServiceType(svc, corev1.ServiceTypeLoadBalancer) // Update metadata err = kubernetes.AddServiceLabel(svc, "env", "prod") err = kubernetes.AddServiceAnnotation(svc, "external-dns.alpha.kubernetes.io/hostname", "app.example.com") Ingress Builders // Create an Ingress ing := kubernetes.CreateIngress("my-app", "default", "nginx") // Build a rule with paths rule := kubernetes.CreateIngressRule("app.example.com") pt := netv1.PathTypePrefix path := kubernetes.CreateIngressPath("/", &amp;pt, "my-app", "http") kubernetes.AddIngressRulePath(rule, path) err := kubernetes.AddIngressRule(ing, rule) // Add TLS err = kubernetes.AddIngressTLS(ing, netv1.IngressTLS{ Hosts: []string{"app.example.com"}, SecretName: "my-app-tls", }) Related Packages fluxcd - FluxCD resource constructors errors - Structured error types used for nil-check sentinels</description></item><item><title>FluxCD Builders</title><link>https://www.gokure.dev/api-reference/fluxcd-builders/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/fluxcd-builders/index.html</guid><description>FluxCD Builders - Flux Resource Constructors The fluxcd package provides strongly-typed constructor functions for creating FluxCD Kubernetes resources. These are the low-level building blocks used by Kure‚Äôs higher-level stack and workflow packages.
Overview Each function takes a configuration struct and returns a fully initialized Flux custom resource. The builders handle API version and kind metadata, letting you focus on the resource specification.
Supported Resources Source Controllers import "github.com/go-kure/kure/pkg/kubernetes/fluxcd" // Git repository source gitRepo := fluxcd.GitRepository(&amp;fluxcd.GitRepositoryConfig{ Name: "my-repo", Namespace: "flux-system", URL: "https://github.com/org/repo", Branch: "main", Interval: "5m", }) // OCI repository source ociRepo := fluxcd.OCIRepository(&amp;fluxcd.OCIRepositoryConfig{ Name: "my-oci", Namespace: "flux-system", URL: "oci://registry.example.com/manifests", Tag: "latest", Interval: "10m", }) // Helm repository helmRepo := fluxcd.HelmRepository(&amp;fluxcd.HelmRepositoryConfig{ Name: "bitnami", Namespace: "flux-system", URL: "https://charts.bitnami.com/bitnami", Interval: "1h", }) // Bucket source bucket := fluxcd.Bucket(&amp;fluxcd.BucketConfig{ Name: "my-bucket", Namespace: "flux-system", Endpoint: "minio.example.com", BucketName: "manifests", }) Deployment Controllers // Kustomization (reconciles manifests from a source) ks := fluxcd.Kustomization(&amp;fluxcd.KustomizationConfig{ Name: "my-app", Namespace: "flux-system", Path: "./clusters/production/apps", Interval: "10m", Prune: true, SourceRef: kustv1.CrossNamespaceSourceReference{ Kind: "GitRepository", Name: "my-repo", }, }) // HelmRelease (reconciles a Helm chart) hr := fluxcd.HelmRelease(&amp;fluxcd.HelmReleaseConfig{ Name: "redis", Namespace: "default", Chart: "redis", Version: "17.0.0", RepoName: "bitnami", RepoNamespace: "flux-system", Values: map[string]interface{}{ "auth": map[string]interface{}{ "enabled": false, }, }, }) Notification Controllers // Alert alert := fluxcd.Alert(&amp;fluxcd.AlertConfig{ Name: "slack-alert", Namespace: "flux-system", Provider: "slack", Severity: "error", }) // Provider provider := fluxcd.Provider(&amp;fluxcd.ProviderConfig{ Name: "slack", Namespace: "flux-system", Type: "slack", Channel: "#alerts", }) // Receiver (for webhooks) receiver := fluxcd.Receiver(&amp;fluxcd.ReceiverConfig{ Name: "github-receiver", Namespace: "flux-system", Type: "github", }) Flux Operator // FluxInstance (for flux-operator deployments) instance := fluxcd.FluxInstance(&amp;fluxcd.FluxInstanceConfig{ Name: "flux", Namespace: "flux-system", }) Modifier Functions Update existing resources:</description></item><item><title>Logger</title><link>https://www.gokure.dev/api-reference/logger/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/logger/index.html</guid><description>Logger - Logging Utilities The logger package provides structured logging for Kure. All logging in the project should use this package instead of fmt.Print or the standard log package.
Overview The logger provides a simple interface for structured key-value logging with support for different log levels. It wraps an underlying structured logger and provides convenience functions.
Usage import "github.com/go-kure/kure/pkg/logger" // Default logger log := logger.Default() // Log with context log.Info("loading package", "path", "/path/to/package") log.Error("failed to parse", "error", err, "file", "config.yaml") // No-op logger (for quiet mode) log := logger.Noop() Log Levels Level Usage Info Normal operational messages Error Error conditions Debug Detailed debugging information Warn Warning conditions Conventions Use key-value pairs for structured data: log.Info("msg", "key1", val1, "key2", val2) Use logger.Noop() when verbose output is disabled Pass the logger through function parameters or options structs Use logger.Default() only at initialization points (CLI entry, tests) Related Packages All Kure packages use this logger. See the errors package for error handling patterns.</description></item><item><title>Compatibility Matrix</title><link>https://www.gokure.dev/api-reference/compatibility/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/api-reference/compatibility/index.html</guid><description>Kure Compatibility Matrix This document describes the versions of infrastructure tools that Kure supports.
Version Philosophy Kure maintains two version concepts for each dependency:
Build Version (current in versions.yaml): The exact library version Kure imports in go.mod Deployment Compatibility (supported_range): The range of deployed tool versions that Kure can generate YAML for Go Version Current: Go 1.24.12
Infrastructure Dependencies Tool Build Version Deployment Compatibility Notes cert-manager 1.16.5 1.14 - 1.16 1.17+ requires Go 1.25 fluxcd 2.6.4 2.4 - 2.6 2.7+ requires Go 1.25, tracked in #128 image-automation-controller 1.0+ requires Go 1.25 (#171) All github.com/fluxcd/* packages blocked from minor/major updates flux-operator 0.24.1 0.23 - 0.24 0.25+ requires Go 1.25 metallb 0.15.2 0.14 - 0.15 0.15.3+ requires Go 1.25 and triggers k8s.io upgrade to 0.34+ (#169) external-secrets 0.19.2 0.18 - 0.19 Compatible with current Go version controller-runtime 0.21.0 0.19 - 0.21 0.22+ requires Go 1.25 kubernetes 0.33.2 1.28 - 1.33 Tested in CI matrix Understanding the Matrix Build Version (go.mod) The version Kure imports and builds against. This is validated by CI to match versions.yaml.</description></item></channel></rss>