<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guides :: Go Kure</title><link>https://www.gokure.dev/guides/index.html</link><description>Guides Step-by-step guides for common Kure workflows.
Using Kure as a Library - Import paths, creating resources, generating YAML Generating Flux Manifests - End-to-end cluster definition to disk Working with Generators - The GVK system and application generators Patching Resources - JSONPath patching and TOML patch format Building Kurel Packages - Creating reusable application packages</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://www.gokure.dev/guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Kure as a Library</title><link>https://www.gokure.dev/guides/library-usage/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/guides/library-usage/index.html</guid><description>Using Kure as a Library Kure is primarily a Go library. This guide covers the basics of importing it, creating resources, and generating YAML output.
Installation go get github.com/go-kure/kure Creating Resources Kure provides typed builder functions for Kubernetes and FluxCD resources.
FluxCD Resources import "github.com/go-kure/kure/pkg/kubernetes/fluxcd" // Create a GitRepository source repo := fluxcd.GitRepository(&amp;fluxcd.GitRepositoryConfig{ Name: "my-repo", Namespace: "flux-system", URL: "https://github.com/org/repo", Branch: "main", Interval: "5m", }) // Create a Kustomization that references the source ks := fluxcd.Kustomization(&amp;fluxcd.KustomizationConfig{ Name: "my-app", Namespace: "flux-system", Path: "./clusters/production", Interval: "10m", Prune: true, SourceRef: kustv1.CrossNamespaceSourceReference{ Kind: "GitRepository", Name: "my-repo", }, }) See the FluxCD Builders reference for all available resource types.</description></item><item><title>Generating Flux Manifests</title><link>https://www.gokure.dev/guides/flux-workflow/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/guides/flux-workflow/index.html</guid><description>Generating Flux Manifests This guide walks through the complete workflow for generating a GitOps repository structure with Flux resources using Kure.
Overview The workflow has four stages:
Define the cluster topology using the domain model Select the Flux workflow engine Generate Flux resources and directory layout Write manifests to disk Step 1: Define the Cluster Use the fluent builder to define your cluster’s structure:
import "github.com/go-kure/kure/pkg/stack" cluster := stack.NewClusterBuilder("production"). WithNode("infrastructure"). WithBundle("cert-manager"). WithApplication("cert-manager", certManagerConfig). End(). End(). WithNode("applications"). WithBundle("web-tier"). WithApplication("frontend", frontendConfig). WithApplication("api-gateway", apiConfig). End(). End(). Build() Each bundle becomes a Flux Kustomization, and each application generates its Kubernetes manifests.</description></item><item><title>Working with Generators</title><link>https://www.gokure.dev/guides/generators/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/guides/generators/index.html</guid><description>Working with Generators Generators provide a type-safe way to create application workloads from configuration. They implement the ApplicationConfig interface and are identified by GroupVersionKind (GVK) strings.
The GVK System Each generator is registered with a GVK identifier that uniquely identifies its type:
GVK Generator Output generators/AppWorkload AppWorkload Deployment, Service, ConfigMap generators/FluxHelm FluxHelm HelmRelease, HelmRepository generators/KurelPackage KurelPackage Kurel package reference Using Generators From Code import "github.com/go-kure/kure/pkg/stack/generators" // Look up generator by GVK factory, err := generators.GetGenerator("generators/AppWorkload") // Create config from YAML data config, err := factory.FromConfig(yamlData) // Use in the domain model app := stack.NewApplication("my-app", "default", config) From YAML Configuration Generators can be configured via YAML files:</description></item><item><title>Patching Resources</title><link>https://www.gokure.dev/guides/patching/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/guides/patching/index.html</guid><description>Patching Resources Kure’s patch system lets you declaratively modify Kubernetes resources using JSONPath expressions. Patches are applied after resource generation, making them useful for environment-specific customization.
When to Patch vs Configure Configure at generation time when you control the resource builder (set replicas, image, etc. in code) Patch after generation when you need to modify resources from external sources, or when the same base resources need different modifications per environment Patch File Formats TOML Format (.kpatch) The TOML format uses section headers to target resources:</description></item><item><title>Building Kurel Packages</title><link>https://www.gokure.dev/guides/kurel-packages/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/guides/kurel-packages/index.html</guid><description>Building Kurel Packages Kurel is the package system for creating reusable Kubernetes applications. A kurel package bundles base manifests, patches, and parameters into a self-contained unit that can be customized per deployment.
Package Structure my-app.kurel/ ├── parameters.yaml # Variables and package metadata ├── resources/ # Base Kubernetes manifests │ ├── deployment.yaml │ ├── service.yaml │ └── namespace.yaml ├── patches/ # Modular customization patches │ ├── 00-base.kpatch # Global settings │ ├── features/ │ │ ├── 10-monitoring.kpatch │ │ └── 10-monitoring.yaml # Patch conditions │ └── profiles/ │ ├── 10-dev.kpatch │ └── 20-prod.kpatch └── README.md Creating a Package 1. Define Parameters # parameters.yaml kurel: name: my-application version: 1.0.0 description: "A sample application package" app: replicas: 3 image: repository: myapp tag: v1.0.0 monitoring: enabled: false 2. Add Base Resources Place standard Kubernetes manifests in resources/. These are the starting point before patches are applied.</description></item></channel></rss>