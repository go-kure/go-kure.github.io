<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Launcher :: Go Kure</title><link>https://www.gokure.dev/packages/launcher/index.html</link><description>Launcher Package The launcher package (formerly kurel) provides a package system for creating reusable, customizable Kubernetes applications without the complexity of templating engines.
It uses a declarative patch-based approach to customize base Kubernetes manifests, enabling composable and type-safe application definitions.
Documentation Overview - Package overview and usage Design - High-level design document Design Details - Detailed design decisions Code Design - Code-level architecture Implementation Plan - Implementation roadmap Architecture - Package architecture API Reference pkg.go.dev/github.com/go-kure/kure/pkg/launcher</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://www.gokure.dev/packages/launcher/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview</title><link>https://www.gokure.dev/packages/launcher/readme/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/readme/index.html</guid><description>Launcher - Kubernetes Resources Launcher This package provides the core functionality for Kurel, the Kubernetes Resources Launcher CLI tool.
Kurel is a package system for creating reusable, customizable Kubernetes applications without the complexity of templating engines. It uses a declarative patch-based approach to customize base Kubernetes manifests, making it perfect for GitOps workflows.
âœ¨ Key Features ğŸ“¦ Package-based - Encapsulate applications in reusable .kurel packages ğŸ¯ No Templating - Use patches instead of complex template syntax ğŸ”§ Declarative Customization - Simple parameter-driven configuration ğŸš€ GitOps Native - Generate clean Kubernetes manifests for Flux/ArgoCD ğŸ“Š Schema Validation - Auto-generated schemas with Kubernetes API integration ğŸ—ï¸ Multi-Phase Deployment - Support for ordered deployment phases ğŸŒ Multi-Namespace - Deploy across multiple namespaces seamlessly ğŸ¨ User Extensions - Extend packages without modifying originals ğŸš€ Quick Start Installing a Package # Download a kurel package (example) git clone https://github.com/example/prometheus-operator.kurel # Validate the package kurel validate prometheus-operator.kurel/ # Customize with your parameters cat &gt; my-values.yaml &lt;&lt; EOF monitoring: enabled: true retention: 7d persistence: enabled: true size: 50Gi resources: requests: cpu: 200m memory: 512Mi EOF # Generate manifests kurel build prometheus-operator.kurel/ \ --values my-values.yaml \ --output ./manifests/ Using with GitOps # Generated structure is GitOps-ready ls manifests/ # pre-install/ - CRDs, namespaces, RBAC # main/ - Main application (depends on pre-install) # post-install/ - Monitoring, backups (depends on main) # Each phase includes kustomization.yaml with proper dependencies cat manifests/main/kustomization.yaml # apiVersion: kustomize.config.k8s.io/v1beta1 # kind: Kustomization # dependsOn: # - name: prometheus-pre-install # resources: [...] ğŸ“ Package Structure A kurel package is a directory with this structure:</description></item><item><title>Design</title><link>https://www.gokure.dev/packages/launcher/design/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/design/index.html</guid><description>Kurel Package System â€” Design Specification This document describes the structure, behavior, and purpose of a Kurel package (Kubernetes Resources Launcher), which encapsulates a reusable, versionable application for Kubernetes. Kurel builds on Kureâ€™s patch engine to enable declarative configuration of application instances without templates or overlays.
Goals Enable reusable packaging of Kubernetes applications Declarative customization via parameters + patches No Helm-style templating or Kustomize overlays Strong schema validation and deployment safety Compatible with GitOps workflows (Flux/ArgoCD) Multi-namespace and multi-phase deployment support Design Philosophy â€œKurel just generates YAMLâ€ - Kurel is a declarative system for generating Kubernetes manifests with validation and customization capabilities. It is not a runtime system, orchestrator, or complex package manager.</description></item><item><title>Design Details</title><link>https://www.gokure.dev/packages/launcher/design-details/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/design-details/index.html</guid><description>Kurel Package System - Comprehensive Design Details This document captures the complete design discussion, decisions, alternatives considered, and rationale for the Kurel (Kubernetes Resources Launcher) package system. It serves as a comprehensive record of all design choices made during the extensive design iteration process.
Design Philosophy &amp; Core Principles Fundamental Philosophy â€œKurel just generates YAMLâ€ - This principle guided every design decision. Kurel is not a runtime system, orchestrator, or complex package manager. Itâ€™s a declarative system for generating Kubernetes manifests with validation and customization capabilities.</description></item><item><title>Code Design</title><link>https://www.gokure.dev/packages/launcher/code-design/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/code-design/index.html</guid><description>Launcher Module - Code Design Overview The launcher module is the core engine for the Kurel package system, implementing a declarative approach to generating Kubernetes manifests with validation and customization capabilities. This document captures all design decisions made during the architecture planning phase.
Design Philosophy Core Principle: â€œKurel just generates YAMLâ€ - The launcher is a declarative system for generating Kubernetes manifests, not a runtime system or orchestrator.
Architecture Decisions 1. Core Package Structure Decision: Immutable PackageDefinition with deep copy support</description></item><item><title>Implementation Plan</title><link>https://www.gokure.dev/packages/launcher/code-implementation-plan/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/code-implementation-plan/index.html</guid><description>Launcher Module - Implementation Plan Overview This document provides a detailed implementation plan for the Kurel launcher module, breaking down the work into concrete tasks with specific implementation details.
Phase 1: Core Foundation (Week 1) Task 1.1: Create Base Types and Interfaces Files to create:
pkg/launcher/types.go - Core data structures pkg/launcher/interfaces.go - Public interfaces pkg/launcher/errors.go - Custom error types Key Considerations:
Resources will handle multi-document YAML (each document becomes separate Resource) Need adapter pattern for existing patch.PatchableAppSet integration Resource type must support conversion to/from unstructured.Unstructured Implementation:</description></item><item><title>Architecture</title><link>https://www.gokure.dev/packages/launcher/architecture/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/launcher/architecture/index.html</guid><description>Launcher Module Architecture Overview The launcher module is a declarative Kubernetes manifest generation system that processes Kurel packages through a well-defined pipeline. It follows clean architecture principles with clear separation of concerns and interface-driven design.
Core Design Principles Interface-Driven Design: All major components are defined as interfaces, enabling testability and flexibility Immutability: Core data structures use deep copy patterns to ensure thread safety Hybrid Error Handling: Distinguishes between blocking errors and non-blocking warnings Performance Optimization: Uses caching, memoization, and efficient algorithms Thread Safety: All components are safe for concurrent use Architecture Layers â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ CLI/API Layer â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Launcher Pipeline â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Load â†’ Resolve â†’ Patch â†’ Valid â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Core Components â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚Loaderâ”‚ â”‚Resolvâ”‚ â”‚Patch â”‚ â”‚Valid â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Data Structures â”‚ â”‚ PackageDefinition, Resource, Patch â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Foundation Layer â”‚ â”‚ errors, logger, io utilities â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Component Architecture 1. Package Loader Responsibility: Load and parse Kurel packages from disk</description></item></channel></rss>