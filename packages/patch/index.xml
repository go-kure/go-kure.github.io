<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Patch :: Go Kure</title><link>https://www.gokure.dev/packages/patch/index.html</link><description>Patch Package The patch package implements a JSONPath-based declarative patching system for Kubernetes resources. It allows you to modify resources using a simple, powerful patch language that maintains YAML structure and comments.
Documentation Design - Patch system design Error Handling - Error handling approach Patch Engine Design - Engine internals Path Resolution - How paths are resolved API Reference pkg.go.dev/github.com/go-kure/kure/pkg/patch</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://www.gokure.dev/packages/patch/index.xml" rel="self" type="application/rss+xml"/><item><title>Design</title><link>https://www.gokure.dev/packages/patch/design/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/patch/design/index.html</guid><description>Kure Patch File Format — Specification This document describes the complete structure and semantics of .kpatch files used in Kure to define Kubernetes resource overrides.
Kure patches are:
Flat, line-based TOML-inspired, but not valid TOML Declarative (no conditionals or logic) Scoped to specific resource kinds and instances 1. File Extension All patch files must use the .kpatch extension. These are plain text files with Kure’s custom patch format.
Examples:
deployment.app.kpatch service.backend.kpatch config.kpatch (merged aggregate) 2. Patch Header Syntax Each patch file is divided into sections. Each section is introduced by a header:</description></item><item><title>Error Handling</title><link>https://www.gokure.dev/packages/patch/error-handling/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/patch/error-handling/index.html</guid><description>Error Handling Philosophy and Guidelines This document establishes the unified error handling philosophy for the Kure patch module, reconciling the current mix of strict and graceful approaches.
Core Philosophy: Graceful by Default, Strict When Critical The patch module should prioritize operational continuity while maintaining data integrity. This means:
Warn and Continue: Missing targets, optional fields, or recoverable issues generate warnings but don’t stop processing Fail Fast: Data corruption, syntax errors, or critical system issues cause immediate failures Rich Context: All errors include actionable information for debugging and resolution Error Categories and Handling Category 1: Graceful Warnings (Continue Processing) These issues generate warnings but allow processing to continue:</description></item><item><title>Patch Engine Design</title><link>https://www.gokure.dev/packages/patch/patch-engine-design/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/patch/patch-engine-design/index.html</guid><description>Kure patch Module — Purpose and Design Purpose The patch module provides the core abstraction layer for loading, representing, and mutating Kubernetes resources using structured patches — without templates, overlays, or DSLs.
It enables tools to declaratively define resource configurations and safe modifications using dual-format support (YAML and TOML) with Go-native data structures. Patches modify an existing base resource, with advanced structure preservation that maintains comments, formatting, and document order.</description></item><item><title>Path Resolution</title><link>https://www.gokure.dev/packages/patch/path-resolution/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/packages/patch/path-resolution/index.html</guid><description>Advanced Path Resolution and Type Inference This document provides an in-depth technical guide to the sophisticated path resolution and type inference systems in the Kure patch module.
Path Resolution Architecture PathPart Structure Each patch path is decomposed into structured components:
type PathPart struct { Field string // The field name (e.g., "containers", "ports") MatchType string // "", "index", or "key" MatchValue string // The match criteria ("0", "name=main") } Path Parsing Process The ParsePatchPath() function converts dot-notation paths into structured segments:</description></item></channel></rss>