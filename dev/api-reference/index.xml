<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API Reference :: Go Kure</title><link>https://www.gokure.dev/dev/api-reference/index.html</link><description>API Reference Kure‚Äôs public API is organized into focused packages. Each package README below is auto-synced from the source code.
For full Go API documentation, see pkg.go.dev/github.com/go-kure/kure .
Core Domain Package Description Reference Stack Cluster, Node, Bundle, Application domain model pkg.go.dev Flux Engine FluxCD workflow implementation pkg.go.dev Generators Application generator system (GVK) pkg.go.dev Layout Engine Manifest directory organization pkg.go.dev Package System Package Description Reference Launcher Kurel package loading, building, validation pkg.go.dev Resource Operations Package Description Reference Patch JSONPath-based declarative patching pkg.go.dev IO YAML/JSON serialization and resource printing pkg.go.dev Kubernetes Builders Core K8s resource constructors (GVK, HPA, PDB) pkg.go.dev FluxCD Builders Low-level Flux resource constructors pkg.go.dev Utilities Package Description Reference Errors Structured error types pkg.go.dev CLI Utilities Factory, IOStreams, Printer pkg.go.dev Logger Structured logging pkg.go.dev Compatibility Compatibility Matrix - Supported Kubernetes and dependency versions ArgoCD ArgoCD support exists at pkg/stack/argocd/ but is not yet production-ready. It is not featured in guides or examples. The Flux workflow is the primary supported GitOps integration.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://www.gokure.dev/dev/api-reference/index.xml" rel="self" type="application/rss+xml"/><item><title>Stack</title><link>https://www.gokure.dev/dev/api-reference/stack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/stack/index.html</guid><description>Stack - Core Domain Model The stack package defines the hierarchical domain model at the heart of Kure. It provides the Cluster, Node, Bundle, and Application abstractions used to describe a complete Kubernetes deployment topology.
Overview Kure models Kubernetes infrastructure as a four-level hierarchy:
Cluster ‚îî‚îÄ‚îÄ Node (tree structure) ‚îî‚îÄ‚îÄ Bundle (deployment unit) ‚îî‚îÄ‚îÄ Application (workload) Each level maps to a concept in GitOps deployment:</description></item><item><title>Flux Engine</title><link>https://www.gokure.dev/dev/api-reference/flux-engine/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/flux-engine/index.html</guid><description>Flux Engine - FluxCD Workflow Implementation The fluxcd package implements the stack.Workflow interface for FluxCD, providing complete Flux resource generation from domain model definitions.
Overview The Flux engine transforms Kure‚Äôs hierarchical domain model (Cluster, Node, Bundle, Application) into FluxCD resources (Kustomizations, source references) organized in a GitOps-ready directory structure.
The engine is composed of three specialized components:
Component Responsibility ResourceGenerator Generates Flux resources from domain objects LayoutIntegrator Integrates resources into directory structures BootstrapGenerator Creates Flux bootstrap manifests Quick Start import "github.com/go-kure/kure/pkg/stack/fluxcd" // Create engine with defaults engine := fluxcd.Engine() // Generate all Flux resources for a cluster objects, err := engine.GenerateFromCluster(cluster) // Or with custom configuration engine = fluxcd.EngineWithConfig( layout.KustomizationExplicit, layout.FluxSeparate, ) Engine Construction // Default engine engine := fluxcd.Engine() // Engine with specific kustomization mode engine := fluxcd.EngineWithMode(layout.KustomizationExplicit) // Engine with full configuration engine := fluxcd.EngineWithConfig(mode, placement) // Engine with custom components engine := fluxcd.NewWorkflowEngine() Resource Generation Generate Flux resources at different hierarchy levels:</description></item><item><title>Generators</title><link>https://www.gokure.dev/dev/api-reference/generators/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/generators/index.html</guid><description>Generators - Application Generator System The generators package provides a type-safe system for creating Kubernetes application workloads from configuration. Generators implement the stack.ApplicationConfig interface, allowing them to be used as applications within the domain model.
Overview Generators use the GroupVersionKind (GVK) type system to identify and instantiate application configurations. Each generator is registered in the stack package‚Äôs global registry and can be referenced by its GVK identifier.</description></item><item><title>Layout Engine</title><link>https://www.gokure.dev/dev/api-reference/layout/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/layout/index.html</guid><description>Layout Module The layout module is a sophisticated system for organizing and writing Kubernetes manifests to disk in directory structures that work with GitOps tools like Flux and ArgoCD.
Core Purpose The layout module transforms Kure‚Äôs in-memory stack representation (Clusters ‚Üí Nodes ‚Üí Bundles ‚Üí Applications) into organized directory structures with proper kustomization.yaml files that GitOps tools can consume.</description></item><item><title>Launcher</title><link>https://www.gokure.dev/dev/api-reference/launcher/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/launcher/index.html</guid><description>Launcher - Kubernetes Resources Launcher This package provides the core functionality for Kurel, the Kubernetes Resources Launcher CLI tool.
Kurel is a package system for creating reusable, customizable Kubernetes applications without the complexity of templating engines. It uses a declarative patch-based approach to customize base Kubernetes manifests, making it perfect for GitOps workflows.
‚ú® Key Features üì¶ Package-based - Encapsulate applications in reusable .kurel packages üéØ No Templating - Use patches instead of complex template syntax üîß Declarative Customization - Simple parameter-driven configuration üöÄ GitOps Native - Generate clean Kubernetes manifests for Flux/ArgoCD üìä Schema Validation - Auto-generated schemas with Kubernetes API integration üèóÔ∏è Multi-Phase Deployment - Support for ordered deployment phases üåê Multi-Namespace - Deploy across multiple namespaces seamlessly üé® User Extensions - Extend packages without modifying originals üöÄ Quick Start Installing a Package # Download a kurel package (example) git clone https://github.com/example/prometheus-operator.kurel # Validate the package kurel validate prometheus-operator.kurel/ # Customize with your parameters cat &gt; my-values.yaml &lt;&lt; EOF monitoring: enabled: true retention: 7d persistence: enabled: true size: 50Gi resources: requests: cpu: 200m memory: 512Mi EOF # Generate manifests kurel build prometheus-operator.kurel/ \ --values my-values.yaml \ --output ./manifests/ Using with GitOps # Generated structure is GitOps-ready ls manifests/ # pre-install/ - CRDs, namespaces, RBAC # main/ - Main application (depends on pre-install) # post-install/ - Monitoring, backups (depends on main) # Each phase includes kustomization.yaml with proper dependencies cat manifests/main/kustomization.yaml # apiVersion: kustomize.config.k8s.io/v1beta1 # kind: Kustomization # dependsOn: # - name: prometheus-pre-install # resources: [...] üìÅ Package Structure A kurel package is a directory with this structure:</description></item><item><title>Patch</title><link>https://www.gokure.dev/dev/api-reference/patch/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/patch/index.html</guid><description>Patch - Declarative Resource Patching The patch package provides a JSONPath-based system for declaratively modifying Kubernetes resources. It supports both TOML and YAML patch file formats with structure-preserving modifications and variable substitution.
Overview Patches allow you to modify Kubernetes manifests without rewriting them. The system uses JSONPath expressions to target specific fields and applies changes while preserving the original YAML structure (comments, ordering, formatting).</description></item><item><title>IO</title><link>https://www.gokure.dev/dev/api-reference/io/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/io/index.html</guid><description>IO - YAML Serialization and Resource Printing The io package provides utilities for parsing, serializing, and printing Kubernetes resources. It supports multiple output formats including YAML, JSON, and kubectl-compatible table views.
Overview This package handles the I/O boundary of Kure: reading Kubernetes manifests from files, serializing resources to YAML/JSON, and printing resources in human-readable formats. It integrates with Kure‚Äôs registered scheme for type-aware parsing.</description></item><item><title>Errors</title><link>https://www.gokure.dev/dev/api-reference/errors/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/errors/index.html</guid><description>Errors - Structured Error Handling The errors package provides structured error types with contextual information for Kubernetes resource operations. All Kure packages use this instead of fmt.Errorf.
Overview Errors in Kure carry context: the type of error, what resource was affected, suggestions for fixing the problem, and the original cause. This makes debugging easier and enables programmatic error handling.</description></item><item><title>CLI Utilities</title><link>https://www.gokure.dev/dev/api-reference/cli/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/cli/index.html</guid><description>CLI - Command-Line Interface Utilities The cli package provides foundational components for Kure‚Äôs CLI tools (kure and kurel). It implements the Factory pattern for dependency injection, I/O stream abstraction, and output formatting.
Overview This package is used internally by the pkg/cmd/ packages to build CLI commands. It provides a clean separation between command logic and I/O handling.
Key Components Factory Dependency injection container for CLI commands. Provides access to global options, I/O streams, and configuration.</description></item><item><title>Kubernetes Builders</title><link>https://www.gokure.dev/dev/api-reference/kubernetes-builders/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/kubernetes-builders/index.html</guid><description>Kubernetes Builders - Core Resource Helpers The kubernetes package provides GVK utilities, scheme registration, and strongly-typed builder functions for core Kubernetes resources.
Overview This package exposes helpers that other Kure packages (and external consumers such as Crane) use to construct and inspect Kubernetes objects without dealing with low-level struct details.
Import import "github.com/go-kure/kure/pkg/kubernetes" GVK Utilities // Resolve the GVK of any registered runtime.Object gvk, err := kubernetes.GetGroupVersionKind(myDeployment) // Check if a GVK is in an allow list ok := kubernetes.IsGVKAllowed(gvk, allowedGVKs) Scheme Registration // Lazily registers all supported API groups (core K8s, FluxCD, cert-manager, etc.) err := kubernetes.RegisterSchemes() HPA Builders // Create a HorizontalPodAutoscaler hpa := kubernetes.CreateHorizontalPodAutoscaler("my-app", "default") // Set the scale target err := kubernetes.SetHPAScaleTargetRef(hpa, "apps/v1", "Deployment", "my-app") // Set replica bounds err = kubernetes.SetHPAMinMaxReplicas(hpa, 2, 10) // Add CPU and memory metrics err = kubernetes.AddHPACPUMetric(hpa, 80) err = kubernetes.AddHPAMemoryMetric(hpa, 70) // Set scaling behavior window := int32(300) err = kubernetes.SetHPABehavior(hpa, &amp;autoscalingv2.HorizontalPodAutoscalerBehavior{ ScaleDown: &amp;autoscalingv2.HPAScalingRules{ StabilizationWindowSeconds: &amp;window, }, }) // Update metadata err = kubernetes.SetHPALabels(hpa, map[string]string{"env": "prod"}) err = kubernetes.SetHPAAnnotations(hpa, map[string]string{"owner": "platform"}) PDB Builders // Create a PodDisruptionBudget pdb := kubernetes.CreatePodDisruptionBudget("my-app", "default") // Set disruption budget (MinAvailable and MaxUnavailable are mutually exclusive) err := kubernetes.SetPDBMinAvailable(pdb, intstr.FromInt32(2)) // or: err = kubernetes.SetPDBMaxUnavailable(pdb, intstr.FromString("25%")) // Set the label selector err = kubernetes.SetPDBSelector(pdb, &amp;metav1.LabelSelector{ MatchLabels: map[string]string{"app": "my-app"}, }) // Update metadata err = kubernetes.SetPDBLabels(pdb, map[string]string{"env": "prod"}) err = kubernetes.SetPDBAnnotations(pdb, map[string]string{"owner": "platform"}) Deployment Builders // Create a Deployment dep := kubernetes.CreateDeployment("my-app", "default") // Add a container container := &amp;corev1.Container{Name: "app", Image: "nginx:1.25"} err := kubernetes.AddDeploymentContainer(dep, container) // Set replicas and strategy err = kubernetes.SetDeploymentReplicas(dep, 3) err = kubernetes.SetDeploymentStrategy(dep, appsv1.DeploymentStrategy{ Type: appsv1.RollingUpdateDeploymentStrategyType, }) // Configure pod template err = kubernetes.SetDeploymentServiceAccountName(dep, "my-sa") err = kubernetes.SetDeploymentNodeSelector(dep, map[string]string{"role": "web"}) err = kubernetes.AddDeploymentToleration(dep, &amp;corev1.Toleration{Key: "dedicated", Value: "web"}) CronJob Builders // Create a CronJob cj := kubernetes.CreateCronJob("my-job", "default", "*/5 * * * *") // Add a container container := &amp;corev1.Container{Name: "worker", Image: "busybox:1.36"} err := kubernetes.AddCronJobContainer(cj, container) // Configure schedule and policies err = kubernetes.SetCronJobConcurrencyPolicy(cj, batchv1.ForbidConcurrent) err = kubernetes.SetCronJobSuccessfulJobsHistoryLimit(cj, 3) err = kubernetes.SetCronJobFailedJobsHistoryLimit(cj, 1) // Configure pod template err = kubernetes.SetCronJobServiceAccountName(cj, "my-sa") err = kubernetes.SetCronJobNodeSelector(cj, map[string]string{"role": "batch"}) err = kubernetes.AddCronJobToleration(cj, &amp;corev1.Toleration{Key: "dedicated", Value: "batch"}) Service Builders // Create a Service svc := kubernetes.CreateService("my-app", "default") // Configure the service err := kubernetes.SetServiceSelector(svc, map[string]string{"app": "my-app"}) err = kubernetes.AddServicePort(svc, corev1.ServicePort{ Name: "http", Port: 80, TargetPort: intstr.FromInt32(8080), }) err = kubernetes.SetServiceType(svc, corev1.ServiceTypeLoadBalancer) // Update metadata err = kubernetes.AddServiceLabel(svc, "env", "prod") err = kubernetes.AddServiceAnnotation(svc, "external-dns.alpha.kubernetes.io/hostname", "app.example.com") Ingress Builders // Create an Ingress ing := kubernetes.CreateIngress("my-app", "default", "nginx") // Build a rule with paths rule := kubernetes.CreateIngressRule("app.example.com") pt := netv1.PathTypePrefix path := kubernetes.CreateIngressPath("/", &amp;pt, "my-app", "http") kubernetes.AddIngressRulePath(rule, path) err := kubernetes.AddIngressRule(ing, rule) // Add TLS err = kubernetes.AddIngressTLS(ing, netv1.IngressTLS{ Hosts: []string{"app.example.com"}, SecretName: "my-app-tls", }) Related Packages fluxcd - FluxCD resource constructors errors - Structured error types used for nil-check sentinels</description></item><item><title>FluxCD Builders</title><link>https://www.gokure.dev/dev/api-reference/fluxcd-builders/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/fluxcd-builders/index.html</guid><description>FluxCD Builders - Flux Resource Constructors The fluxcd package provides strongly-typed constructor functions for creating FluxCD Kubernetes resources. These are the low-level building blocks used by Kure‚Äôs higher-level stack and workflow packages.
Overview Each function takes a configuration struct and returns a fully initialized Flux custom resource. The builders handle API version and kind metadata, letting you focus on the resource specification.</description></item><item><title>Logger</title><link>https://www.gokure.dev/dev/api-reference/logger/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/logger/index.html</guid><description>Logger - Logging Utilities The logger package provides structured logging for Kure. All logging in the project should use this package instead of fmt.Print or the standard log package.
Overview The logger provides a simple interface for structured key-value logging with support for different log levels. It wraps an underlying structured logger and provides convenience functions.
Usage import "github.com/go-kure/kure/pkg/logger" // Default logger log := logger.Default() // Log with context log.Info("loading package", "path", "/path/to/package") log.Error("failed to parse", "error", err, "file", "config.yaml") // No-op logger (for quiet mode) log := logger.Noop() Log Levels Level Usage Info Normal operational messages Error Error conditions Debug Detailed debugging information Warn Warning conditions Conventions Use key-value pairs for structured data: log.Info("msg", "key1", val1, "key2", val2) Use logger.Noop() when verbose output is disabled Pass the logger through function parameters or options structs Use logger.Default() only at initialization points (CLI entry, tests) Related Packages All Kure packages use this logger. See the errors package for error handling patterns.</description></item><item><title>Compatibility Matrix</title><link>https://www.gokure.dev/dev/api-reference/compatibility/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.gokure.dev/dev/api-reference/compatibility/index.html</guid><description>Kure Compatibility Matrix This document describes the versions of infrastructure tools that Kure supports.
Version Philosophy Kure maintains two version concepts for each dependency:
Build Version (current in versions.yaml): The exact library version Kure imports in go.mod Deployment Compatibility (supported_range): The range of deployed tool versions that Kure can generate YAML for Go Version Current: Go 1.24.12
Infrastructure Dependencies Tool Build Version Deployment Compatibility Notes cert-manager 1.16.5 1.14 - 1.16 1.17+ requires Go 1.25 fluxcd 2.6.4 2.4 - 2.6 2.7+ requires Go 1.25, tracked in #128 image-automation-controller 1.0+ requires Go 1.25 (#171) All github.com/fluxcd/* packages blocked from minor/major updates flux-operator 0.24.1 0.23 - 0.24 0.25+ requires Go 1.25 metallb 0.15.2 0.14 - 0.15 0.15.3+ requires Go 1.25 and triggers k8s.io upgrade to 0.34+ (#169) external-secrets 0.19.2 0.18 - 0.19 Compatible with current Go version controller-runtime 0.21.0 0.19 - 0.21 0.22+ requires Go 1.25 kubernetes 0.33.2 1.28 - 1.33 Tested in CI matrix Understanding the Matrix Build Version (go.mod) The version Kure imports and builds against. This is validated by CI to match versions.yaml.</description></item></channel></rss>